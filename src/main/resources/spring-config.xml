<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:util="http://www.springframework.org/schema/util"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- Enable usage of @Autowired. -->
    <context:annotation-config/>

    <!-- Enable component scanning for defining beans with annotations. -->
    <context:component-scan base-package="es.udc.tfg_es.clubtriatlon.model"/>

    <!--  For translating native persistence exceptions to Spring's 
          DataAccessException hierarchy. -->
	<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>

	<!--  Data source. -->
	<bean id="dataSource"
		class="org.springframework.jndi.JndiObjectFactoryBean"
		p:jndiName="${dataSource.jndiName}"
		p:resourceRef="true" />
		
<!-- 	<bean class="java.net.URI" id="dbUrl"> -->
<!-- 		<constructor-arg value="#{systemEnvironment['CLUBTRIATLON_DATABASE_URL']}"/> -->
<!-- 	</bean> -->
<!-- 	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"> -->
<!-- 		<property name="url"      value="#{ 'jdbc:mysql://' + @dbUrl.getHost() + ':' + @dbUrl.getPort() + @dbUrl.getPath() }"/> -->
<!-- 		<property name="username" value="#{ @dbUrl.getUserInfo().split(':')[0] }"/> -->
<!-- 		<property name="password" value="#{ @dbUrl.getUserInfo().split(':')[1] }"/> -->
<!-- 	</bean> -->
<!-- 	<bean id="dataSource" -->
<!-- 		class="org.springframework.jndi.JndiObjectFactoryBean" -->
<!-- 		p:jndiName="#{ 'java:comp/env/jdbc' + @dbUrl.getPath() }" -->
<!-- 		p:resourceRef="true" /> -->
	<bean id="dataSourceProxy" class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"
		p:targetDataSource-ref="dataSource"/>

	<!-- Hibernate Session Factory -->
    <bean id="sessionFactory"
        class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"
        p:dataSource-ref="dataSourceProxy"
        p:configLocation="classpath:/hibernate.cfg.xml"/>

    <!-- Transaction manager for a single Hibernate SessionFactory.  -->
    <bean id="transactionManager"
        class="org.springframework.orm.hibernate4.HibernateTransactionManager"
        p:sessionFactory-ref="sessionFactory" />

	<!-- Enable the configuration of transactional behavior based on
	     annotations. -->
    <tx:annotation-driven transaction-manager="transactionManager" />


    <!-- Apache Shiro -->

    <!-- La aplicación no tiene permisos, solo roles, pero debemos definir una consulta en permissionsQuery
         o usará la consulta por defecto (otras tablas, atributos...). De momento dejo esto así pero ver si
         hay alguna manera de omitirla si no estará realizando siempre una consulta, con join...-->
    <bean id="jdbcRealm" class="org.apache.shiro.realm.jdbc.JdbcRealm">
        <property name="name" value="jdbcRealm" />
        <property name="dataSource" ref="dataSource" />
        <property name="authenticationQuery" value="SELECT enPassword as password
                                                    FROM UserProfile
                                                    WHERE email = ?" />
        <property name="userRolesQuery" value="SELECT r.name as role_name
                                               FROM UserProfile u INNER JOIN Role r ON (u.usrId = r.userId)
                                               WHERE u.email = ?" />
        <property name="permissionsQuery" value="SELECT r.name as role_name
                                                 FROM UserProfile u INNER JOIN Role r ON (u.usrId = r.userId)
                                                 WHERE u.email = ?" />
        <property name="permissionsLookupEnabled" value="true"></property>
        <property name="cachingEnabled" value="true" />
    </bean>

<!-- Define the Shiro Realm implementation you want to use to connect to your back-end -->
<!-- security datasource: --><!-- Con la clase que cree redefiniendo los métodos, no va... -->
<!-- <bean id="userProfileRealm" class="es.udc.tfg_es.clubtriatlon.web.services.UserProfileRealm"/> -->

    <bean id="sessionManager" class="org.apache.shiro.session.mgt.DefaultSessionManager">
        <property name="sessionValidationSchedulerEnabled" value="false"/>
    </bean>
<!-- Define any javax.servlet.Filter beans you want anywhere in this application context.   -->
<!-- They will automatically be acquired by the 'shiroFilter' bean above and made available -->
<!-- to the 'filterChainDefinitions' property.  Or you can manually/explicitly add them     -->
<!-- to the shiroFilter's 'filters' Map if desired. See its JavaDoc for more details.       -->
<!-- <bean id="someFilter" class="..."/> -->
<!-- <bean id="anotherFilter" class="..."> ... </bean> -->

<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
    <!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. -->
    <property name="realm" ref="jdbcRealm"/><!-- <property name="realm" ref="userProfileRealm"/>-->
    <property name="sessionManager" ref="sessionManager"/>
    <!-- By default the servlet container sessions will be used.  Uncomment this line
         to use shiro's native sessions (see the JavaDoc for more): -->
    <!-- <property name="sessionMode" value="native"/> -->
</bean>

    <bean id="formAuthenticationFilter" class="org.apache.shiro.web.filter.authc.FormAuthenticationFilter">
        <property name="usernameParam" value="email"/>
        <property name="passwordParam" value="password"/>
        <property name="rememberMeParam" value="rememberMe"/>
        <property name="loginUrl" value="/login"/>
    </bean>
    
<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
    <property name="securityManager" ref="securityManager"/>
<!--     <property name="loginUrl" value="/login"/> -->
<!--     <property name="successUrl" value="/index"/> -->
    <property name="unauthorizedUrl" value="/index"/>
    <!-- The 'filters' property is not necessary since any declared javax.servlet.Filter bean  -->
    <!-- defined will be automatically acquired and available via its beanName in chain        -->
    <!-- definitions, but you can perform instance overrides or name aliases here if you like: -->
<!--     <property name="filters"> -->
<!--         <util:map> -->
<!--             <entry key="authc" value-ref="formAuthenticationFilter"/> -->
<!--         </util:map> -->
<!--     </property> -->
    <property name="filterChainDefinitions">
        <value>
            # some example chain definitions:
            /admin/** = authc, roles[admin]
            # more URL-to-FilterChain definitions here
        </value>
    </property>
</bean>


<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>


<!-- Enable Shiro Annotations for Spring-configured beans.  Only run after -->
<!-- the lifecycleBeanProcessor has run: -->
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/>
<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
    <property name="securityManager" ref="securityManager"/>
</bean>

</beans>
